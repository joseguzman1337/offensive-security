# CVE-2025-49734 Continuous Security Monitoring & Compliance
# Real-time vulnerability assessment and automated remediation
# Author: Security Operations Team
# Version: 2.1.0

#Requires -Version 5.1
#Requires -RunAsAdministrator

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# Monitoring Configuration
$MONITOR_INTERVAL = 300  # 5 minutes
$COMPLIANCE_REPORT_INTERVAL = 3600  # 1 hour
$SECURITY_LOG = "$env:ProgramData\Security\CVE-Monitor.log"
$COMPLIANCE_DB = "$env:ProgramData\Security\Compliance.json"
$ALERT_THRESHOLD = 'HIGH'

# SIEM Integration
$SIEM_ENDPOINT = $env:SIEM_ENDPOINT ?? 'https://***MASKED***:8080/api/events'
$SIEM_API_KEY = Get-VaultSecret -Path 'siem/api' -Key 'token'

# Security baseline configuration
$SECURITY_BASELINE = @{
    'PowerShellDirectDisabled' = $true
    'WinRMDisabled' = $true
    'FirewallRulesConfigured' = $true
    'SecurityUpdatesInstalled' = $true
    'SystemIntegrityValid' = $true
    'AuditLoggingEnabled' = $true
    'ExecutionPolicySecure' = $true
}

function Send-SecurityAlert {
    param(
        [Parameter(Mandatory)][string]$AlertType,
        [Parameter(Mandatory)][string]$Message,
        [ValidateSet('LOW','MEDIUM','HIGH','CRITICAL')][string]$Severity = 'MEDIUM',
        [hashtable]$Metadata = @{}
    )
    
    $alert = @{
        'timestamp' = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'
        'cve_id' = 'CVE-2025-49734'
        'alert_type' = $AlertType
        'severity' = $Severity
        'message' = $Message
        'hostname' = $env:COMPUTERNAME
        'metadata' = $Metadata
    }
    
    try {
        # Send to SIEM
        if ($SIEM_API_KEY -and $SIEM_ENDPOINT) {
            $headers = @{
                'Authorization' = "Bearer $SIEM_API_KEY"
                'Content-Type' = 'application/json'
            }
            
            $body = $alert | ConvertTo-Json -Depth 3
            Invoke-RestMethod -Uri $SIEM_ENDPOINT -Method POST -Headers $headers -Body $body -TimeoutSec 10
        }
        
        # Local logging
        $logEntry = "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] [ALERT] [$Severity] $AlertType - $Message"
        Add-Content -Path $SECURITY_LOG -Value $logEntry -Encoding UTF8
        
        # Windows Event Log
        if (-not (Get-EventLog -List | Where-Object Log -eq 'CVE-Security')) {
            New-EventLog -LogName 'CVE-Security' -Source 'CVE-Monitor'
        }
        
        $eventType = switch ($Severity) {
            'LOW' { 'Information' }
            'MEDIUM' { 'Warning' }
            'HIGH' { 'Error' }
            'CRITICAL' { 'Error' }
        }
        
        Write-EventLog -LogName 'CVE-Security' -Source 'CVE-Monitor' -EntryType $eventType -EventId 49734 -Message "$AlertType - $Message"
        
    } catch {
        Write-Warning "Failed to send security alert: $($_.Exception.Message)"
    }
}

function Test-ContinuousCompliance {
    Write-Host "Performing continuous compliance validation..."
    
    $complianceResults = @{}
    $overallCompliant = $true
    
    foreach ($control in $SECURITY_BASELINE.Keys) {
        $result = switch ($control) {
            'PowerShellDirectDisabled' {
                $regKey = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers'
                if (Test-Path $regKey) {
                    $value = Get-ItemProperty -Path $regKey -Name 'DisablePowerShellDirect' -ErrorAction SilentlyContinue
                    $value -and $value.DisablePowerShellDirect -eq 1
                } else {
                    $false
                }
            }
            
            'WinRMDisabled' {
                $winrmSvc = Get-Service -Name WinRM -ErrorAction SilentlyContinue
                $winrmSvc -and $winrmSvc.Status -eq 'Stopped' -and $winrmSvc.StartType -eq 'Disabled'
            }
            
            'FirewallRulesConfigured' {
                $rules = Get-NetFirewallRule -DisplayName 'Block-PowerShellDirect-*' -ErrorAction SilentlyContinue
                $rules.Count -ge 4  # Should have 4 blocking rules
            }
            
            'SecurityUpdatesInstalled' {
                $requiredKBs = @('KB5065306', 'KB5065432', 'KB5065426', 'KB5065429')
                $installedKBs = Get-HotFix | Select-Object -ExpandProperty HotFixID
                $missing = $requiredKBs | Where-Object { $_ -notin $installedKBs }
                $missing.Count -eq 0
            }
            
            'SystemIntegrityValid' {
                try {
                    $integrityCheck = sfc /verifyonly 2>&1
                    $LASTEXITCODE -eq 0
                } catch {
                    $false
                }
            }
            
            'AuditLoggingEnabled' {
                $auditPolicy = auditpol /get /category:"Logon/Logoff" 2>&1
                $auditPolicy -match 'Success and Failure'
            }
            
            'ExecutionPolicySecure' {
                $policy = Get-ExecutionPolicy -Scope LocalMachine
                $policy -in @('AllSigned', 'RemoteSigned', 'Restricted')
            }
        }
        
        $complianceResults[$control] = $result
        if (-not $result) {
            $overallCompliant = $false
            Send-SecurityAlert -AlertType 'COMPLIANCE_VIOLATION' -Message "Security control '$control' is not compliant" -Severity 'HIGH' -Metadata @{ 'control' = $control }
        }
    }
    
    # Update compliance database
    $complianceRecord = @{
        'timestamp' = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'
        'overall_compliant' = $overallCompliant
        'controls' = $complianceResults
        'risk_score' = if ($overallCompliant) { 10 } else { 85 }
    }
    
    try {
        $complianceHistory = @()
        if (Test-Path $COMPLIANCE_DB) {
            $complianceHistory = Get-Content $COMPLIANCE_DB | ConvertFrom-Json -ErrorAction SilentlyContinue
            if (-not $complianceHistory) { $complianceHistory = @() }
        }
        
        $complianceHistory += $complianceRecord
        # Keep only last 24 hours of records
        $cutoff = (Get-Date).AddHours(-24)
        $complianceHistory = $complianceHistory | Where-Object { [datetime]$_.timestamp -gt $cutoff }
        
        $complianceHistory | ConvertTo-Json -Depth 3 | Out-File -FilePath $COMPLIANCE_DB -Encoding UTF8
    } catch {
        Write-Warning "Failed to update compliance database: $($_.Exception.Message)"
    }
    
    return $overallCompliant
}

function Start-ThreatHunting {
    Write-Host "Performing automated threat hunting for CVE-2025-49734 exploitation..."
    
    # Check for suspicious PowerShell processes
    $suspiciousPS = Get-Process | Where-Object {
        $_.ProcessName -eq 'powershell' -and $_.CommandLine -match '(Invoke-Command|Enter-PSSession|New-PSSession).*-ComputerName.*-Credential'
    }
    
    if ($suspiciousPS) {
        Send-SecurityAlert -AlertType 'THREAT_DETECTED' -Message "Suspicious PowerShell activity detected - potential CVE-2025-49734 exploitation" -Severity 'CRITICAL' -Metadata @{ 'processes' = $suspiciousPS.Id }
    }
    
    # Monitor Windows Event Logs for PowerShell Direct events
    $psDirectEvents = Get-WinEvent -FilterHashtable @{
        LogName = 'Microsoft-Windows-PowerShell/Operational'
        Id = 4103, 4104, 4105, 4106
        StartTime = (Get-Date).AddMinutes(-5)
    } -ErrorAction SilentlyContinue | Where-Object {
        $_.Message -match '(PowerShell Direct|PSDirectVMLegacy|Hyper-V)'
    }
    
    if ($psDirectEvents) {
        Send-SecurityAlert -AlertType 'SUSPICIOUS_ACTIVITY' -Message "PowerShell Direct activity detected in event logs" -Severity 'HIGH' -Metadata @{ 'event_count' = $psDirectEvents.Count }
    }
    
    # Check for failed authentication attempts (Event ID 4625)
    $failedLogins = Get-WinEvent -FilterHashtable @{
        LogName = 'Security'
        Id = 4625
        StartTime = (Get-Date).AddMinutes(-5)
    } -ErrorAction SilentlyContinue | Where-Object {
        $_.Message -match 'PSDirectVMLegacy'
    }
    
    if ($failedLogins) {
        Send-SecurityAlert -AlertType 'ATTACK_INDICATOR' -Message "CVE-2025-49734 attack indicators found - PSDirectVMLegacy login failures" -Severity 'CRITICAL' -Metadata @{ 'failed_attempts' = $failedLogins.Count }
    }
    
    # Network connection monitoring
    $suspiciousConnections = Get-NetTCPConnection | Where-Object {
        $_.LocalPort -in @(5985, 5986) -and $_.State -eq 'Established'
    }
    
    if ($suspiciousConnections) {
        Send-SecurityAlert -AlertType 'NETWORK_ANOMALY' -Message "Active connections on PowerShell remoting ports detected" -Severity 'HIGH' -Metadata @{ 'connections' = $suspiciousConnections.Count }
    }
}

function Invoke-AutoRemediation {
    param([string]$ThreatType)
    
    Write-Host "Attempting automatic remediation for threat: $ThreatType"
    
    switch ($ThreatType) {
        'COMPLIANCE_VIOLATION' {
            # Re-apply security controls
            & ".\Untitled1.ps1"
        }
        
        'THREAT_DETECTED' {
            # Kill suspicious processes
            $suspiciousPS = Get-Process | Where-Object {
                $_.ProcessName -eq 'powershell' -and $_.CommandLine -match 'PowerShell Direct'
            }
            $suspiciousPS | Stop-Process -Force
            
            # Disable PowerShell remoting
            Disable-PSRemoting -Force
        }
        
        'NETWORK_ANOMALY' {
            # Block suspicious connections
            $connections = Get-NetTCPConnection | Where-Object {
                $_.LocalPort -in @(5985, 5986) -and $_.State -eq 'Established'
            }
            
            foreach ($conn in $connections) {
                try {
                    New-NetFirewallRule -DisplayName "Block-Suspicious-$($conn.RemoteAddress)" -Direction Inbound -RemoteAddress $conn.RemoteAddress -Action Block
                } catch {
                    Write-Warning "Failed to block connection from $($conn.RemoteAddress)"
                }
            }
        }
    }
    
    Send-SecurityAlert -AlertType 'AUTO_REMEDIATION' -Message "Automatic remediation performed for $ThreatType" -Severity 'MEDIUM'
}

function Start-ContinuousMonitoring {
    Write-Host "Starting continuous monitoring for CVE-2025-49734..."
    Send-SecurityAlert -AlertType 'MONITOR_START' -Message "CVE-2025-49734 continuous monitoring initiated" -Severity 'LOW'
    
    $lastComplianceCheck = Get-Date
    $monitoringActive = $true
    
    # Set up performance counters
    $perfCounters = @(
        '\Process(powershell*)\% Processor Time',
        '\Network Interface(*)\Packets/sec',
        '\Security System Performance\NTLM Authentications/sec'
    )
    
    try {
        while ($monitoringActive) {
            $currentTime = Get-Date
            
            # Continuous threat hunting
            Start-ThreatHunting
            
            # Periodic compliance check
            if (($currentTime - $lastComplianceCheck).TotalSeconds -gt $COMPLIANCE_REPORT_INTERVAL) {
                $compliant = Test-ContinuousCompliance
                if (-not $compliant) {
                    Invoke-AutoRemediation -ThreatType 'COMPLIANCE_VIOLATION'
                }
                $lastComplianceCheck = $currentTime
            }
            
            # Monitor system resources
            $cpuUsage = (Get-Counter '\Processor(_Total)\% Processor Time' -SampleInterval 1 -MaxSamples 1).CounterSamples.CookedValue
            if ($cpuUsage -gt 90) {
                Send-SecurityAlert -AlertType 'RESOURCE_ANOMALY' -Message "High CPU usage detected: $cpuUsage%" -Severity 'MEDIUM'
            }
            
            # Sleep until next monitoring cycle
            Start-Sleep -Seconds $MONITOR_INTERVAL
            
            # Check for termination signal
            if (Test-Path "$env:TEMP\stop-cve-monitor") {
                Remove-Item "$env:TEMP\stop-cve-monitor" -Force
                $monitoringActive = $false
            }
        }
    } catch {
        Send-SecurityAlert -AlertType 'MONITOR_ERROR' -Message "Monitoring error: $($_.Exception.Message)" -Severity 'HIGH'
    } finally {
        Send-SecurityAlert -AlertType 'MONITOR_STOP' -Message "CVE-2025-49734 continuous monitoring stopped" -Severity 'LOW'
    }
}

function Get-VaultSecret {
    param(
        [Parameter(Mandatory)][string]$Path,
        [Parameter(Mandatory)][string]$Key
    )
    
    try {
        $vaultTokenFile = "$env:USERPROFILE\.vault-token"
        if (-not (Test-Path $vaultTokenFile)) {
            return $null
        }
        
        $vaultToken = Get-Content $vaultTokenFile -Raw
        $headers = @{
            'X-Vault-Token' = $vaultToken
            'Content-Type' = 'application/json'
        }
        
        $vaultAddr = $env:VAULT_ADDR ?? 'http://***MASKED***:8200'
        $response = Invoke-RestMethod -Uri "$vaultAddr/v1/$Path" -Headers $headers -Method GET -TimeoutSec 10
        return $response.data.$Key
    } catch {
        Write-Warning "Failed to retrieve secret from Vault: $($_.Exception.Message)"
        return $null
    }
}

# Main execution
if ($args.Count -eq 0 -or $args[0] -eq 'monitor') {
    Start-ContinuousMonitoring
} elseif ($args[0] -eq 'compliance') {
    Test-ContinuousCompliance
} elseif ($args[0] -eq 'hunt') {
    Start-ThreatHunting
} else {
    Write-Host "Usage: .\CVE-2025-49734-Monitor.ps1 [monitor|compliance|hunt]"
    Write-Host "  monitor    - Start continuous monitoring (default)"
    Write-Host "  compliance - Run compliance check once"
    Write-Host "  hunt       - Run threat hunting once"
}
