# CVE-2025-49734 Security Validation & Testing Framework
# Comprehensive validation of all implemented security controls
# Author: Security Operations Team
# Version: 2.1.0

#Requires -Version 5.1
#Requires -RunAsAdministrator

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Continue'

# Test Results Tracking
$TestResults = @()
$PassedTests = 0
$FailedTests = 0

function Write-TestResult {
    param(
        [Parameter(Mandatory)][string]$TestName,
        [Parameter(Mandatory)][bool]$Passed,
        [string]$Details = "",
        [string]$Recommendation = ""
    )
    
    $result = @{
        'TestName' = $TestName
        'Status' = if ($Passed) { 'PASS' } else { 'FAIL' }
        'Timestamp' = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        'Details' = $Details
        'Recommendation' = $Recommendation
    }
    
    $script:TestResults += $result
    
    if ($Passed) {
        Write-Host "[PASS] $TestName" -ForegroundColor Green
        $script:PassedTests++
    } else {
        Write-Host "[FAIL] $TestName" -ForegroundColor Red
        if ($Details) { Write-Host "   Details: $Details" -ForegroundColor Yellow }
        if ($Recommendation) { Write-Host "   Recommendation: $Recommendation" -ForegroundColor Cyan }
        $script:FailedTests++
    }
}

function Test-PowerShellDirectVulnerability {
    Write-Host "`nTesting PowerShell Direct Vulnerability (CVE-2025-49734)..." -ForegroundColor Blue
    
    # Test 1: Check if Hyper-V is installed
    try {
        $hyperVFeature = Get-WindowsFeature -Name Hyper-V -ErrorAction SilentlyContinue
        $hyperVInstalled = $hyperVFeature -and $hyperVFeature.InstallState -eq 'Installed'
        
        Write-TestResult -TestName "Hyper-V Installation Check" -Passed (-not $hyperVInstalled) -Details "Hyper-V Status: $($hyperVFeature.InstallState)" -Recommendation "If Hyper-V is not needed, keep it uninstalled to reduce attack surface"
    } catch {
        Write-TestResult -TestName "Hyper-V Installation Check" -Passed $true -Details "Get-WindowsFeature not available - likely not Windows Server"
    }
    
    # Test 2: PowerShell Direct Registry Settings
    $psDirectKeys = @(
        'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers',
        'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System',
        'HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell'
    )
    
    $allKeysProperlConfigured = $true
    foreach ($key in $psDirectKeys) {
        try {
            if (Test-Path $key) {
                $disableValue = Get-ItemProperty -Path $key -Name 'DisablePowerShellDirect' -ErrorAction SilentlyContinue
                if (-not $disableValue -or $disableValue.DisablePowerShellDirect -ne 1) {
                    $allKeysProperlConfigured = $false
                    break
                }
            } else {
                $allKeysProperlConfigured = $false
                break
            }
        } catch {
            $allKeysProperlConfigured = $false
            break
        }
    }
    
    Write-TestResult -TestName "PowerShell Direct Registry Mitigation" -Passed $allKeysProperlConfigured -Details "Registry keys checked: $($psDirectKeys.Count)" -Recommendation "Run the patched mitigation script to configure registry settings"
    
    # Test 3: PowerShell Version Vulnerability
    $psVersion = $PSVersionTable.PSVersion
    $isVulnerableVersion = $false
    
    $vulnerableVersions = @{
        '5.1' = '5.1.19041.5909'
        '7.4' = '7.4.12'
        '7.5' = '7.5.3'
    }
    
    $majorMinor = "$($psVersion.Major).$($psVersion.Minor)"
    if ($vulnerableVersions.ContainsKey($majorMinor)) {
        $requiredVersion = [version]$vulnerableVersions[$majorMinor]
        $currentVersion = [version]"$($psVersion.Major).$($psVersion.Minor).$($psVersion.Build).$($psVersion.Revision)"
        $isVulnerableVersion = $currentVersion -lt $requiredVersion
    }
    
    $requiredVersionText = if ($vulnerableVersions.ContainsKey($majorMinor)) { $vulnerableVersions[$majorMinor] } else { 'N/A' }
    Write-TestResult -TestName "PowerShell Version Security" -Passed (-not $isVulnerableVersion) -Details "Current: $currentVersion, Required: $requiredVersionText" -Recommendation "Update PowerShell to latest secure version"
}

function Test-SecurityUpdates {
    Write-Host "`nTesting Security Updates Installation..." -ForegroundColor Blue
    
    # Define required KBs based on OS
    $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem
    $osVersion = $osInfo.Caption
    
    $requiredKBs = @()
    if ($osVersion -like "*Windows Server 2022*") {
        $requiredKBs = @('KB5065306', 'KB5065432')
    } elseif ($osVersion -like "*Windows 11*") {
        $requiredKBs = @('KB5065426', 'KB5065474')
    } elseif ($osVersion -like "*Windows 10*") {
        $requiredKBs = @('KB5065429')
    }
    
    if ($requiredKBs.Count -eq 0) {
        Write-TestResult -TestName "Security Updates Applicability" -Passed $true -Details "No specific KBs required for OS: $osVersion"
        return
    }
    
    # Check installed updates using multiple methods
    $installedKBs = @()
    
    # Method 1: Get-HotFix
    try {
        $hotfixes = Get-HotFix | Select-Object -ExpandProperty HotFixID
        $installedKBs += $hotfixes
    } catch {
        Write-Warning "Could not retrieve hotfixes via Get-HotFix"
    }
    
    # Method 2: Windows Update History
    try {
        $updateSession = New-Object -ComObject Microsoft.Update.Session
        $updateSearcher = $updateSession.CreateUpdateSearcher()
        $historyCount = $updateSearcher.GetTotalHistoryCount()
        $updateHistory = $updateSearcher.QueryHistory(0, [Math]::Min($historyCount, 100))
        
        foreach ($update in $updateHistory) {
            if ($update.Title -and $update.ResultCode -eq 2) {  # Successfully installed
                foreach ($kb in $requiredKBs) {
                    if ($update.Title -match $kb) {
                        $installedKBs += $kb
                    }
                }
            }
        }
    } catch {
        Write-Warning "Could not check Windows Update history"
    }
    
    $missingKBs = @($requiredKBs | Where-Object { $_ -notin $installedKBs })
    $allUpdatesInstalled = $missingKBs.Count -eq 0
    
    Write-TestResult -TestName "Required Security Updates" -Passed $allUpdatesInstalled -Details "Missing KBs: $($missingKBs -join ', ')" -Recommendation "Install missing security updates via Windows Update or manual download"
    
    foreach ($kb in $requiredKBs) {
        $kbInstalled = $kb -in $installedKBs
        Write-TestResult -TestName "Security Update $kb" -Passed $kbInstalled -Details "Installation status checked via multiple methods" -Recommendation "Install $kb from Microsoft Update Catalog"
    }
}

function Test-NetworkSecurity {
    Write-Host "`nTesting Network Security Configuration..." -ForegroundColor Blue
    
    # Test 1: WinRM Service Status
    try {
        $winrmService = Get-Service -Name WinRM -ErrorAction SilentlyContinue
        $winrmSecure = $winrmService -and $winrmService.Status -eq 'Stopped' -and $winrmService.StartType -eq 'Disabled'
        
        Write-TestResult -TestName "WinRM Service Security" -Passed $winrmSecure -Details "Status: $($winrmService.Status), StartType: $($winrmService.StartType)" -Recommendation "Disable WinRM service if not required for legitimate administration"
    } catch {
        Write-TestResult -TestName "WinRM Service Security" -Passed $true -Details "WinRM service not found"
    }
    
    # Test 2: PowerShell Remoting Ports
    $dangerousPorts = @(5985, 5986)
    $activeConnections = @(Get-NetTCPConnection | Where-Object { $_.LocalPort -in $dangerousPorts -and $_.State -eq 'Listen' })
    
    $noActiveListeners = $activeConnections.Count -eq 0
    Write-TestResult -TestName "PowerShell Remoting Ports" -Passed $noActiveListeners -Details "Active listeners on ports 5985/5986: $($activeConnections.Count)" -Recommendation "Close PowerShell remoting ports if not required"
    
    # Test 3: Firewall Rules
    try {
        $firewallRules = Get-NetFirewallRule -DisplayName 'Block-PowerShellDirect-*' -ErrorAction SilentlyContinue
        $properFirewallConfig = $firewallRules.Count -ge 4
        
        Write-TestResult -TestName "PowerShell Direct Firewall Rules" -Passed $properFirewallConfig -Details "Blocking rules found: $($firewallRules.Count)" -Recommendation "Configure firewall rules to block PowerShell Direct connections"
    } catch {
        Write-TestResult -TestName "PowerShell Direct Firewall Rules" -Passed $false -Details "Could not check firewall rules" -Recommendation "Manually verify firewall configuration"
    }
    
    # Test 4: Network Connections Analysis
    $suspiciousConnections = @(Get-NetTCPConnection | Where-Object {
        $_.LocalPort -in @(5985, 5986) -and $_.State -eq 'Established'
    })
    
    $noSuspiciousConnections = $suspiciousConnections.Count -eq 0
    Write-TestResult -TestName "Suspicious Network Connections" -Passed $noSuspiciousConnections -Details "Active PowerShell remoting connections: $($suspiciousConnections.Count)" -Recommendation "Investigate any active PowerShell remoting connections"
}

function Test-SystemIntegrity {
    Write-Host "`nTesting System Integrity..." -ForegroundColor Blue
    
    # Test 1: System File Integrity
    try {
        $sfcResult = sfc /verifyonly 2>&1
        $systemIntegrityValid = $LASTEXITCODE -eq 0
        
        Write-TestResult -TestName "System File Integrity" -Passed $systemIntegrityValid -Details "SFC exit code: $LASTEXITCODE" -Recommendation "Run 'sfc /scannow' to repair corrupted system files"
    } catch {
        Write-TestResult -TestName "System File Integrity" -Passed $false -Details "Could not run system file checker" -Recommendation "Manually run sfc /scannow as administrator"
    }
    
    # Test 2: PowerShell Execution Policy
    $executionPolicies = Get-ExecutionPolicy -List
    $machinePolicy = $executionPolicies | Where-Object Scope -eq 'LocalMachine'
    
    $secureExecutionPolicy = $machinePolicy.ExecutionPolicy -in @('AllSigned', 'RemoteSigned', 'Restricted')
    Write-TestResult -TestName "PowerShell Execution Policy" -Passed $secureExecutionPolicy -Details "LocalMachine Policy: $($machinePolicy.ExecutionPolicy)" -Recommendation "Set execution policy to RemoteSigned or AllSigned"
    
    # Test 3: Audit Logging
    try {
        $auditPolicy = auditpol /get /category:"Logon/Logoff" 2>&1
        $auditingEnabled = $auditPolicy -match 'Success and Failure'
        
        Write-TestResult -TestName "Security Audit Logging" -Passed $auditingEnabled -Details "Logon/Logoff auditing status checked" -Recommendation "Enable comprehensive audit logging for security events"
    } catch {
        Write-TestResult -TestName "Security Audit Logging" -Passed $false -Details "Could not check audit policy" -Recommendation "Configure audit policies for security monitoring"
    }
}

function Test-ThreatDetection {
    Write-Host "`nTesting Threat Detection Capabilities..." -ForegroundColor Blue
    
    # Test 1: Event Log Configuration
    try {
        $psOperationalLog = Get-WinEvent -ListLog 'Microsoft-Windows-PowerShell/Operational' -ErrorAction SilentlyContinue
        $eventLoggingConfigured = $psOperationalLog -and $psOperationalLog.IsEnabled
        
        Write-TestResult -TestName "PowerShell Operational Logging" -Passed $eventLoggingConfigured -Details "Log enabled: $($psOperationalLog.IsEnabled)" -Recommendation "Enable PowerShell operational logging for threat detection"
    } catch {
        Write-TestResult -TestName "PowerShell Operational Logging" -Passed $false -Details "Could not check PowerShell operational log" -Recommendation "Configure PowerShell logging"
    }
    
    # Test 2: Security Event Log
    try {
        $securityLog = Get-WinEvent -ListLog 'Security' -ErrorAction SilentlyContinue
        $securityLoggingActive = $securityLog -and $securityLog.IsEnabled
        
        Write-TestResult -TestName "Security Event Logging" -Passed $securityLoggingActive -Details "Security log enabled: $($securityLog.IsEnabled)" -Recommendation "Ensure Security event log is properly configured"
    } catch {
        Write-TestResult -TestName "Security Event Logging" -Passed $false -Details "Could not check Security event log" -Recommendation "Verify Security event log configuration"
    }
    
    # Test 3: Suspicious Process Detection
    $suspiciousProcesses = @(Get-Process | Where-Object {
        $_.ProcessName -match '(mimikatz|psexec|pwdump|fgdump|gsecdump|cachedump|lsadump)'
    })
    
    $noSuspiciousProcesses = $suspiciousProcesses.Count -eq 0
    Write-TestResult -TestName "Suspicious Process Detection" -Passed $noSuspiciousProcesses -Details "Suspicious processes found: $($suspiciousProcesses.Count)" -Recommendation "Investigate any suspicious processes immediately"
    
    # Test 4: Recent PowerShell Direct Events
    try {
        $recentPSEvents = Get-WinEvent -FilterHashtable @{
            LogName = 'Microsoft-Windows-PowerShell/Operational'
            StartTime = (Get-Date).AddHours(-24)
        } -MaxEvents 100 -ErrorAction SilentlyContinue | Where-Object {
            $_.Message -match '(PowerShell Direct|PSDirectVMLegacy|Hyper-V)'
        }
        
        $noPSDirectActivity = $recentPSEvents.Count -eq 0
        Write-TestResult -TestName "Recent PowerShell Direct Activity" -Passed $noPSDirectActivity -Details "PowerShell Direct events in last 24h: $($recentPSEvents.Count)" -Recommendation "Investigate any PowerShell Direct activity"
    } catch {
        Write-TestResult -TestName "Recent PowerShell Direct Activity" -Passed $true -Details "Could not check PowerShell events - likely no activity"
    }
}

function Test-CredentialSecurity {
    Write-Host "`nTesting Credential Security..." -ForegroundColor Blue
    
    # Test 1: Vault Token File Security
    $vaultTokenFile = "$env:USERPROFILE\.vault-token"
    if (Test-Path $vaultTokenFile) {
        $tokenFilePerms = Get-Acl $vaultTokenFile
        $tokenFileSecure = $tokenFilePerms.Owner -eq "$env:USERDOMAIN\$env:USERNAME"
        
        Write-TestResult -TestName "Vault Token File Security" -Passed $tokenFileSecure -Details "Token file exists, owner: $($tokenFilePerms.Owner)" -Recommendation "Ensure vault token file has restrictive permissions"
    } else {
        Write-TestResult -TestName "Vault Token File Security" -Passed $true -Details "No vault token file found - using environment variables"
    }
    
    # Test 2: Environment Variable Security
    $sensitiveEnvVars = @('VAULT_TOKEN', 'VAULT_ADDR', 'SIEM_API_KEY', 'SIEM_ENDPOINT')
    $exposedSecrets = @()
    
    foreach ($envVar in $sensitiveEnvVars) {
        $value = [Environment]::GetEnvironmentVariable($envVar)
        if ($value -and $value.Length -gt 10) {
            $exposedSecrets += $envVar
        }
    }
    
    $noExposedSecrets = $exposedSecrets.Count -eq 0
    Write-TestResult -TestName "Environment Variable Security" -Passed $noExposedSecrets -Details "Potentially exposed secrets: $($exposedSecrets.Count)" -Recommendation "Use secure credential storage instead of environment variables"
}

function Generate-ComplianceReport {
    Write-Host "`nGenerating Compliance Report..." -ForegroundColor Blue
    
    $totalTests = $PassedTests + $FailedTests
    $compliancePercentage = if ($totalTests -gt 0) { [Math]::Round(($PassedTests / $totalTests) * 100, 2) } else { 0 }
    
    $report = @{
        'CVE_ID' = 'CVE-2025-49734'
        'Report_Generated' = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        'System_Info' = @{
            'Hostname' = $env:COMPUTERNAME
            'OS' = (Get-CimInstance Win32_OperatingSystem).Caption
            'PowerShell_Version' = $PSVersionTable.PSVersion.ToString()
        }
        'Test_Summary' = @{
            'Total_Tests' = $totalTests
            'Passed_Tests' = $PassedTests
            'Failed_Tests' = $FailedTests
            'Compliance_Percentage' = $compliancePercentage
            'Overall_Status' = if ($compliancePercentage -ge 90) { 'COMPLIANT' } elseif ($compliancePercentage -ge 70) { 'PARTIALLY_COMPLIANT' } else { 'NON_COMPLIANT' }
        }
        'Detailed_Results' = $TestResults
    }
    
    # Save detailed report
    $reportJson = $report | ConvertTo-Json -Depth 4
    $reportPath = "CVE-2025-49734-Validation-Report-$(Get-Date -Format 'yyyyMMdd-HHmmss').json"
    $reportJson | Out-File -FilePath $reportPath -Encoding UTF8
    
    # Display summary
    Write-Host "`n" "="*80 -ForegroundColor Cyan
    Write-Host " CVE-2025-49734 SECURITY VALIDATION REPORT" -ForegroundColor Cyan
    Write-Host "="*80 -ForegroundColor Cyan
    Write-Host "System: $env:COMPUTERNAME" -ForegroundColor White
    Write-Host "Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor White
    Write-Host ""
    Write-Host "Test Results:" -ForegroundColor Yellow
    Write-Host "  Total Tests: $totalTests" -ForegroundColor White
    Write-Host "  Passed: $PassedTests" -ForegroundColor Green
    Write-Host "  Failed: $FailedTests" -ForegroundColor Red
    Write-Host "  Compliance: $compliancePercentage%" -ForegroundColor $(if ($compliancePercentage -ge 90) { 'Green' } elseif ($compliancePercentage -ge 70) { 'Yellow' } else { 'Red' })
    Write-Host ""
    Write-Host "Overall Status: $($report.Test_Summary.Overall_Status)" -ForegroundColor $(if ($report.Test_Summary.Overall_Status -eq 'COMPLIANT') { 'Green' } elseif ($report.Test_Summary.Overall_Status -eq 'PARTIALLY_COMPLIANT') { 'Yellow' } else { 'Red' })
    Write-Host ""
    Write-Host "Detailed report saved to: $reportPath" -ForegroundColor Cyan
    Write-Host "="*80 -ForegroundColor Cyan
    
    return $report
}

# Main execution
Write-Host "CVE-2025-49734 Security Validation Framework" -ForegroundColor Cyan
Write-Host "Starting comprehensive security testing..." -ForegroundColor White

try {
    Test-PowerShellDirectVulnerability
    Test-SecurityUpdates
    Test-NetworkSecurity
    Test-SystemIntegrity
    Test-ThreatDetection
    Test-CredentialSecurity
    
    $complianceReport = Generate-ComplianceReport
    
    if ($complianceReport.Test_Summary.Overall_Status -eq 'COMPLIANT') {
        Write-Host "`nSystem is COMPLIANT with CVE-2025-49734 mitigation requirements" -ForegroundColor Green
        exit 0
    } elseif ($complianceReport.Test_Summary.Overall_Status -eq 'PARTIALLY_COMPLIANT') {
        Write-Host "`nSystem is PARTIALLY COMPLIANT - some improvements needed" -ForegroundColor Yellow
        exit 1
    } else {
        Write-Host "`nSystem is NON_COMPLIANT - immediate action required" -ForegroundColor Red
        exit 2
    }
    
} catch {
    Write-Host "`nCritical error during validation: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Yellow
    exit 3
}
